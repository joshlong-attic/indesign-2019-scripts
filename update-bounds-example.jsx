 main();function main(){	if(app.documents.length != 0){		if(app.selection.length != 0){			var selectedTextFrames = [];			var count = app.selection.length; 			for (var i = 0; i < count; i++) {				if (app.selection[i].constructor.name == 'TextFrame') {					selectedTextFrames.push(app.selection[i]);				}			}			offsetTextFrames(selectedTextFrames);		}	}} function readBoundsFor( element ){	var ib = element.geometricBounds ;	var y=0, x=1, y2=2, x2=3 ; // offsets into the geometric bounds 	var bounds =  { 		y  : ib[y], 		x  : ib[x],	    x2 : ib[x2], 	    y2 : ib[y2] 	};	bounds.w = bounds.x2 - bounds.x; 	bounds.h = bounds.y2 - bounds.y;		var s = '';	for (p in bounds) { 		s += p + ': ' + bounds[p] + '\n'; 	}  	bounds.toString = function (){ return s; };	return bounds;}function writeBoundsFor (element, updatedBounds){	var existingBounds = readBoundsFor(element);	var x  = updatedBounds.x  || existingBounds.x;	var y  = updatedBounds.y  || existingBounds.y;	var y2 = updatedBounds.y2 || existingBounds.y2;	var x2 = updatedBounds.x2 || existingBounds.x2;	element.geometricBounds = [y, x, y2, x2];}function offsetTextFrames (arrayofTextFrames) {	for (var i=0; i < arrayofTextFrames.length; i++){		var element = arrayofTextFrames[i];		var bounds = readBoundsFor(element);		writeBoundsFor(element, { y: bounds.y + 10, y2: bounds.y2 + 10  });	}}